"""Image to G-code conversion.

Mirrors LaserGRBL's RasterConverter/ImageProcessor.cs functionality:
- Line-by-line scanning (horizontal, vertical, diagonal)
- Dithering (Floyd-Steinberg, Ordered, Atkinson)
- Configurable resolution, speed, and power
"""

import math
from enum import Enum, auto
from typing import List, Tuple, Optional

import numpy as np
from PIL import Image, ImageOps, ImageFilter


class ScanDirection(Enum):
    HORIZONTAL = auto()
    VERTICAL = auto()
    DIAGONAL = auto()


class DitherMethod(Enum):
    NONE = auto()           # Grayscale (power modulation via S command)
    FLOYD_STEINBERG = auto()
    ORDERED_4X4 = auto()
    ATKINSON = auto()
    THRESHOLD = auto()


class ConversionMode(Enum):
    LINE_TO_LINE = auto()   # Grayscale line scanning with S power modulation
    DITHERING = auto()      # 1-bit dithering


# 4x4 Bayer ordered dither matrix
BAYER_4X4 = np.array([
    [ 0,  8,  2, 10],
    [12,  4, 14,  6],
    [ 3, 11,  1,  9],
    [15,  7, 13,  5],
], dtype=np.float32) / 16.0


def image_to_gcode(
    image_path: str,
    resolution_dpi: float = 254,       # ~0.1mm per pixel
    feed_rate: float = 1000,           # mm/min
    max_power: int = 1000,             # S value for full black
    min_power: int = 0,                # S value for full white
    scan_direction: ScanDirection = ScanDirection.HORIZONTAL,
    conversion_mode: ConversionMode = ConversionMode.LINE_TO_LINE,
    dither_method: DitherMethod = DitherMethod.FLOYD_STEINBERG,
    invert: bool = False,
    border_speed: float = 3000,        # mm/min for rapid moves
    laser_mode: bool = True,           # Use M4 (dynamic) vs M3 (constant)
    width_mm: Optional[float] = None,  # Target width in mm (auto-scale)
    height_mm: Optional[float] = None, # Target height in mm (auto-scale)
    brightness: float = 0.0,           # -1.0 to 1.0
    contrast: float = 0.0,            # -1.0 to 1.0
    sharpen: bool = False,
) -> List[str]:
    """Convert an image file to G-code lines.

    Returns a list of G-code strings ready to be streamed.
    """
    # Load and preprocess image
    img = Image.open(image_path).convert("L")  # Grayscale

    if invert:
        img = ImageOps.invert(img)

    # Apply brightness/contrast
    if brightness != 0 or contrast != 0:
        img = _adjust_brightness_contrast(img, brightness, contrast)

    if sharpen:
        img = img.filter(ImageFilter.SHARPEN)

    # Calculate pixel size
    pixel_mm = 25.4 / resolution_dpi

    # Scale image if target dimensions specified
    if width_mm and height_mm:
        new_w = int(width_mm / pixel_mm)
        new_h = int(height_mm / pixel_mm)
        img = img.resize((new_w, new_h), Image.LANCZOS)
    elif width_mm:
        new_w = int(width_mm / pixel_mm)
        ratio = new_w / img.width
        new_h = int(img.height * ratio)
        img = img.resize((new_w, new_h), Image.LANCZOS)
    elif height_mm:
        new_h = int(height_mm / pixel_mm)
        ratio = new_h / img.height
        new_w = int(img.width * ratio)
        img = img.resize((new_w, new_h), Image.LANCZOS)

    pixels = np.array(img, dtype=np.float32)

    # Apply dithering if needed
    if conversion_mode == ConversionMode.DITHERING:
        pixels = _apply_dithering(pixels, dither_method)

    # Generate G-code
    gcode = []
    gcode.append("; Generated by PyLaserGRBL")
    gcode.append(f"; Image: {image_path}")
    gcode.append(f"; Size: {img.width}x{img.height} pixels, "
                 f"{img.width * pixel_mm:.1f}x{img.height * pixel_mm:.1f} mm")
    gcode.append(f"; Resolution: {resolution_dpi} DPI ({pixel_mm:.4f} mm/pixel)")
    gcode.append("")
    gcode.append("G90")        # Absolute positioning
    gcode.append("G21")        # Millimeters
    laser_cmd = "M4" if laser_mode else "M3"
    gcode.append(f"{laser_cmd} S0")  # Laser on, power 0

    if scan_direction == ScanDirection.HORIZONTAL:
        gcode.extend(_scan_horizontal(pixels, pixel_mm, feed_rate, max_power,
                                       min_power, conversion_mode, border_speed))
    elif scan_direction == ScanDirection.VERTICAL:
        gcode.extend(_scan_vertical(pixels, pixel_mm, feed_rate, max_power,
                                     min_power, conversion_mode, border_speed))
    elif scan_direction == ScanDirection.DIAGONAL:
        gcode.extend(_scan_diagonal(pixels, pixel_mm, feed_rate, max_power,
                                     min_power, conversion_mode, border_speed))

    gcode.append("M5")         # Laser off
    gcode.append("G0 X0 Y0")  # Return home
    return gcode


def _adjust_brightness_contrast(img: Image.Image, brightness: float, contrast: float) -> Image.Image:
    """Apply brightness and contrast adjustments."""
    arr = np.array(img, dtype=np.float32)
    # Brightness: shift
    arr += brightness * 255
    # Contrast: scale around midpoint
    factor = (1.0 + contrast)
    arr = 128 + factor * (arr - 128)
    arr = np.clip(arr, 0, 255)
    return Image.fromarray(arr.astype(np.uint8))


def _apply_dithering(pixels: np.ndarray, method: DitherMethod) -> np.ndarray:
    """Apply dithering to convert grayscale to 1-bit."""
    h, w = pixels.shape

    if method == DitherMethod.THRESHOLD:
        return (pixels < 128).astype(np.float32) * 255

    elif method == DitherMethod.ORDERED_4X4:
        result = np.zeros_like(pixels)
        for y in range(h):
            for x in range(w):
                threshold = BAYER_4X4[y % 4, x % 4] * 255
                result[y, x] = 255.0 if pixels[y, x] < threshold else 0.0
        return result

    elif method == DitherMethod.FLOYD_STEINBERG:
        img = pixels.copy()
        for y in range(h):
            for x in range(w):
                old = img[y, x]
                new = 0.0 if old < 128 else 255.0
                img[y, x] = new
                err = old - new
                if x + 1 < w:
                    img[y, x + 1] += err * 7 / 16
                if y + 1 < h:
                    if x - 1 >= 0:
                        img[y + 1, x - 1] += err * 3 / 16
                    img[y + 1, x] += err * 5 / 16
                    if x + 1 < w:
                        img[y + 1, x + 1] += err * 1 / 16
        return (img < 128).astype(np.float32) * 255

    elif method == DitherMethod.ATKINSON:
        img = pixels.copy()
        for y in range(h):
            for x in range(w):
                old = img[y, x]
                new = 0.0 if old < 128 else 255.0
                img[y, x] = new
                err = (old - new) / 8.0
                for dx, dy in [(1, 0), (2, 0), (-1, 1), (0, 1), (1, 1), (0, 2)]:
                    nx, ny = x + dx, y + dy
                    if 0 <= nx < w and 0 <= ny < h:
                        img[ny, nx] += err
        return (img < 128).astype(np.float32) * 255

    return pixels


def _pixel_to_power(pixel_val: float, max_power: int, min_power: int) -> int:
    """Convert a grayscale pixel (0=black, 255=white) to laser power.
    Black = high power, White = low power (inverted).
    """
    # 0 (black) → max_power, 255 (white) → min_power
    ratio = 1.0 - (pixel_val / 255.0)
    return int(min_power + ratio * (max_power - min_power))


def _scan_horizontal(pixels: np.ndarray, pixel_mm: float, feed: float,
                      max_power: int, min_power: int,
                      mode: ConversionMode, border_speed: float) -> List[str]:
    """Generate horizontal line-by-line scanning G-code."""
    h, w = pixels.shape
    gcode = []
    left_to_right = True

    for y in range(h):
        y_mm = y * pixel_mm
        row = pixels[y]

        # Skip fully white rows
        if mode == ConversionMode.DITHERING:
            if np.all(row == 0):  # All white in dithered (0 = white after threshold)
                left_to_right = not left_to_right
                continue
        else:
            if np.all(row > 250):
                left_to_right = not left_to_right
                continue

        if left_to_right:
            # Find first and last non-white pixel
            start_x = 0
            end_x = w - 1
            gcode.append(f"G0 X{start_x * pixel_mm:.4f} Y{y_mm:.4f}")

            if mode == ConversionMode.DITHERING:
                # Binary: emit segments of laser-on
                x = 0
                while x < w:
                    if row[x] > 128:  # Black pixel (laser on)
                        seg_start = x
                        while x < w and row[x] > 128:
                            x += 1
                        gcode.append(f"G1 X{seg_start * pixel_mm:.4f} S0 F{feed:.0f}")
                        gcode.append(f"G1 X{x * pixel_mm:.4f} S{max_power} F{feed:.0f}")
                    else:
                        x += 1
                gcode.append(f"G1 X{w * pixel_mm:.4f} S0 F{feed:.0f}")
            else:
                # Grayscale: modulate S per pixel (or group similar pixels)
                prev_power = -1
                for x in range(w):
                    power = _pixel_to_power(row[x], max_power, min_power)
                    if power != prev_power or x == w - 1:
                        gcode.append(f"G1 X{(x + 1) * pixel_mm:.4f} S{power} F{feed:.0f}")
                        prev_power = power
        else:
            gcode.append(f"G0 X{(w - 1) * pixel_mm:.4f} Y{y_mm:.4f}")

            if mode == ConversionMode.DITHERING:
                x = w - 1
                while x >= 0:
                    if row[x] > 128:
                        seg_start = x
                        while x >= 0 and row[x] > 128:
                            x -= 1
                        gcode.append(f"G1 X{(seg_start + 1) * pixel_mm:.4f} S0 F{feed:.0f}")
                        gcode.append(f"G1 X{(x + 1) * pixel_mm:.4f} S{max_power} F{feed:.0f}")
                    else:
                        x -= 1
                gcode.append(f"G1 X0.0000 S0 F{feed:.0f}")
            else:
                prev_power = -1
                for x in range(w - 1, -1, -1):
                    power = _pixel_to_power(row[x], max_power, min_power)
                    if power != prev_power or x == 0:
                        gcode.append(f"G1 X{x * pixel_mm:.4f} S{power} F{feed:.0f}")
                        prev_power = power

        left_to_right = not left_to_right

    return gcode


def _scan_vertical(pixels: np.ndarray, pixel_mm: float, feed: float,
                    max_power: int, min_power: int,
                    mode: ConversionMode, border_speed: float) -> List[str]:
    """Generate vertical scanning G-code (transpose and use horizontal logic)."""
    return _scan_horizontal(pixels.T, pixel_mm, feed, max_power, min_power, mode, border_speed)


def _scan_diagonal(pixels: np.ndarray, pixel_mm: float, feed: float,
                    max_power: int, min_power: int,
                    mode: ConversionMode, border_speed: float) -> List[str]:
    """Generate 45-degree diagonal scanning G-code."""
    h, w = pixels.shape
    gcode = []
    diag_step = pixel_mm * math.sqrt(2) / 2

    # Scan along diagonals (top-left to bottom-right)
    for d in range(w + h - 1):
        points = []
        for y in range(max(0, d - w + 1), min(h, d + 1)):
            x = d - y
            if 0 <= x < w:
                points.append((x, y, pixels[y, x]))

        if not points:
            continue

        # Alternate direction
        if d % 2 == 1:
            points.reverse()

        # Move to start of diagonal
        sx, sy, _ = points[0]
        gcode.append(f"G0 X{sx * pixel_mm:.4f} Y{sy * pixel_mm:.4f}")

        for x, y, val in points:
            power = _pixel_to_power(val, max_power, min_power)
            if mode == ConversionMode.DITHERING:
                power = max_power if val > 128 else 0
            gcode.append(f"G1 X{x * pixel_mm:.4f} Y{y * pixel_mm:.4f} S{power} F{feed:.0f}")

    return gcode
